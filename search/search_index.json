{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Unreal SDK","text":"<p>The Beamable SDK provides functionality to integrate your game with the Beamable features. These range from Content (Remote Config) to Events to Inventory to Microservices (Beamable's unique approach to a Cloud Code Solution).</p> <p>Here's a bit of our philosophy when desing the SDK so you know a bit what to expect:</p> <ul> <li>The SDK's source code is entirely available and modifiable inside your project by you.<ul> <li>In case you modify the SDK's source code, we cannot guarantee that its features will work.</li> <li>We trust you to know when doing so might be worth it for you (VCS are your friend here).</li> </ul> </li> <li>The SDK keeps itself as simple as possible, providing extension points and clear documented.<ul> <li>We believe that tools are either helpful or useless. If you find yourself working around parts of the SDK instead of using them even with MicroServices/Storages, reach out to us.</li> </ul> </li> <li>The SDK is careful about assumptions it makes.<ul> <li>Whenever we have to make an assumption, we try to be explicit about what it means.</li> <li>MicroServices/Storages are great ways to \"just write what you want instead\" when using our default services is not a good fit.</li> </ul> </li> </ul>"},{"location":"#beamable-cli","title":"Beamable CLI","text":"<p>Most of the Beamable workflows are enabled through the Beamable CLI; our editor integrations making use of it to create Engine-specific workflows.</p> <p>The SDK is tightly integrated with the CLI in some ways more than others. For example:</p> <ul> <li>Content, being designer-focused, has its own UE-familiar content editing UI so you can edit the various JSON blobs that defines your game's content. </li> <li>Microservices, however, being more engineer focused, leans more directly on the CLI.</li> </ul> <p>In other words: The Beamable CLI is invisible to the user where it needs to be and explicit to users that need to work with them.</p>"},{"location":"#where-to-start","title":"Where to start?","text":"<p>Regardless of who you are, we recommend run through the Introduction to the SDK and Runtime Concepts documents. After this, it depends on what you're game is or what you are looking to do.</p> <ul> <li>If you are a game maker looking to implement simple and common back-end features, take a look at the docs for Inventory, for currency and items, and Stats, for player-scoped key-value stores.</li> <li>If you are a game maker looking to implement highly specific features, browse the documentation for Content and Microservices to think about how to structure your game's data and custom data with Beamable.</li> <li>If you are looking to integrate Beamable into your game through Unreal's <code>IOnlineSubsystem</code>, take a look at the Online Subsystem Beamable.</li> </ul> <p>If you have any questions, feel free to contact us through one of our Customer Success channels.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Content/","title":"Content","text":"<p>Beamable's Content feature is a read-only (at runtime) arbitrary data store that you can use to define your game's data. Several of Beamable's own managed features also use content in some way or another.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Content/#ubeamcontentobject-and-sub-types","title":"<code>UBeamContentObject</code> and Sub-types","text":"<p>In Unreal, you define content schemas as sub-classes of UBeamContentObject or any of its sub-types available in the SDK ( UBeamItemContent , UBeamGameType , etc...). Every content type must define a unique string id for that particular type and a function that returns it.</p> <p>The following example of UBeamCurrencyContent shows how that can be done:</p> <pre><code>UCLASS(BlueprintType)\nclass BEAMABLECORE_API UBeamCurrencyContent : public UBeamContentObject\n{\n    GENERATED_BODY()\npublic:\n    // Define the ContentTypeId for this type.\n    UFUNCTION()\n    void GetContentType_UBeamCurrencyContent(FString&amp; Result){ Result = TEXT(\"currency\"); }\n\n    // Define the properties you wish\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    FBeamClientPermission clientPermission;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    int64 startingAmount;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, DisplayName=\"Federation\")\n    FOptionalBeamFederation external;\n};\n</code></pre> <p>Please remember to annotate your <code>UPROPERTY</code> with <code>EditAnywhere</code> and either:</p> <ul> <li><code>BlueprintReadOnly</code> if you are not writing utilities to create the objects for you.</li> <li><code>BlueprintReadWrite</code> if you are writing utilities to create the objects for you.</li> </ul> <p>Microservices</p> <p>In a lot of cases, you will want to access these content objects in Microservices.  For all of Beamable's own content-types ( UBeamCurrencyContent , etc...) you will find equivalents in the Microservice SDK. For your own custom types, you'll need to declare them in C#. To do so, use the serialization table below as reference to know how to map types from C++ to C#.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Content/#supported-content-serialization","title":"Supported Content Serialization","text":"Serializable Type In C# Microservices Notes Primitive Types <code>uint8</code> , <code>int32</code> , and <code>int64</code> <code>byte</code>, <code>int</code> and <code>long</code>. <code>float</code> and <code>double</code>. <code>bool</code> Unreal Types <code>FString</code>, <code>FText</code>, <code>FName</code> <code>string</code> These get serialized as JSON strings. <code>FGameplayTag</code> <code>string</code> <code>FGameplayTag::RequestGameplayTag</code> for deserialization. <code>FGameplayTagContainer</code> <code>string</code> <code>FGameplayTagContainer::FromExportString</code> for deserialization. <code>UClass*</code> <code>string</code> Gets converted to <code>FSoftObjectPath</code> when serializing. Deserializing will first create the <code>FSoftObjectPath</code> and then resolve it. <code>TSoftObjectPtr</code> <code>string</code> Gets converted to <code>FSoftObjectPath</code> when serializing. When <code>None</code> serializes as an empty <code>string</code>. <code>TArray&lt;&gt;</code> <code>List&lt;&gt;</code> or <code>T[]</code> Any <code>TArray&lt;SomeType&gt;</code> will serialize normally as long as <code>SomeType</code> is also supported. <code>TMap&lt;FString, &gt;</code> <code>Dictionary&lt;string,&gt;</code> We only support maps with <code>FString</code> as keys. The values can be any supported type. Beamable Types <code>FBeamOptional</code> <code>Optional____</code> Any property of a type implementing <code>FBeamOptional</code> doesn't get serialized if <code>IsSet==false</code> but does get serialized otherwise.For example, <code>FOptionalInt32</code> serializes to nothing OR an <code>int32</code>. <code>FBeamSemanticType</code> <code>string</code> OR semantic type equivalent in C# This always gets serialized as a JSON blob when inside <code>UBeamContentObject</code>. <code>FBeamArray</code> and <code>FBeamMap</code> <code>ArrayOf</code> and <code>MapOf</code> Any implementation of these wrappers are serialized correctly as JSON arrays and JSONobjects respectively. These are only used whenyou want to nest <code>TArray&lt;TArray&lt;&gt;&gt;</code> / <code>TMap&lt;,TMap&lt;&gt;&gt;</code> and still have Blueprint Support. <code>FBeamJsonSerializableUStruct</code> Any C# class that maps to your struct Any type inheriting from this type gets serialized as a JSON object. <code>IBeamJsonSerializableUObject</code> Any C# class that maps to your class <code>UObject</code> in content should have their classesannotated with <code>DefaultToInstanced</code>,<code>EditInlineNew</code> since you shouldn't referenceassets directly inside content objects.For that, use <code>TSoftObjectPtr&lt;&gt;</code>. <p>Take a look at <code>UMockBeamContentObject</code> to see the supported types.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Content/#beamables-content-system","title":"Beamable's Content System","text":"<p>Beamable Content System allows you to define arbitrary JSON-serialized data for use at runtime. The system is manifest-based and has no server-side schema enforcing (which means you are solely responsible for maintaining backward compatibility for your custom content objects).</p> <p>Each individual content object in each manifest is identified by an ID with the format below:</p> <p>ContentTypeId.ContentName</p> <p>ContentType expands to the hierarchy of UBeamContentObject types, starting from the root type. For example:</p> <p><code>UMyGameItemContent</code> inherits from <code>UBeamItemContent</code> <code>items.mygameitem.MyGameItemName</code></p> <p>The last part of the id is the only one you should edit through the Content Window.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Content/#at-runtime","title":"At Runtime","text":"<p>The SDK fetches the content manifest before the <code>OnBeamableStarted</code> callback is triggered. By default, it downloads the content manifest and each individual piece of content. You can enable and disable this behaviour it can be configured to do so inside <code>Project Settings -&gt; Beamable Runtime</code>.</p> <p></p> <p>The SDK also supports automated content updates: once a user is signed into Beamable, our <code>UBeamContentSubsystem</code> begins to listen for notifications that the realm's content manifest has been updated from Beamable's server. If that happens, we will re-download the manifest. Again, we only download individual content pieces if that setting is on. There is an API you can use to manually download individual content pieces: <code>FetchIndividualContentBatchOperation</code> and <code>FetchIndividualContentOperation</code>.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Content/#the-content-manifest","title":"The Content Manifest","text":"<p>At any given time, a Beamable realm has one or more active Content Manifests. By default, and for most cases, the automatically created global manifest is the only one you need. To create, update and delete modify and access <code>UBeamContentObject</code> instances at authoring time, you need to:</p> <ol> <li>Synchronize your local state with what's in the realm (download the manifest).</li> <li>Create content JSON files inside the <code>.beamable/content</code> folder.<ol> <li>The Content Window is the easiest way of doing so.</li> </ol> </li> <li>Synchronize your changes to the Realm (publish the manifest).</li> </ol> <p>In Unreal, you interact with your content objects through the Content Window. It shows you the current state of content relative to your current realm and allows you:</p> <ul> <li>Download: Download the content files currently published to your realm. This is non-destructive; it won't discard new files, just restore deleted ones and discard changes of existing ones.</li> <li>Reset: This is a destructive version of download. After it ends, your local content will 100% reflect what's in the realm.</li> <li>Publish: This is the reverse-reset. It'll make your realm an 100% match to your local content.</li> </ul> <p>This UX looks and follows what you expect of editing any <code>UObject</code>. The difference is that the <code>UBeamContentObject</code> instances are NOT stored inside your Unreal project. They are the <code>.json</code> files inside <code>.beamable/content</code> folder.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Content/#baking-content","title":"Baking Content","text":"<p>In preparation for our Offline Mode support, we provide a editor utility that will bake a content manifest into a <code>UBeamContentCache</code>; this is a special asset type that has the <code>UBeamContentObject</code> instances serialized using UE's serialization as opposed to JSON. </p> <p>This is loaded automatically by the <code>UBeamContentSubsystem</code> if it exists and is configured correctly. We provide an editor utility blueprint you can run to generate and configure the cache for each of your content manifests. The <code>EBP_BakeContent</code> utility can be found in Beamable Core's plugin folder under <code>/Editor/Utility/EBP_BakeContent.EBP_BakeContent</code>.</p> <p>I can't find the Beamable Core Content in the Content Browser</p> <p>UE's Content Browser does not show Plugin content folders by default. If you want to see these, you need to turn it on at <code>Content Browser -&gt; Settings -&gt; Show Plugin Content</code>.</p> <p>Running this utility goes through each of your manifests (<code>.beamable/content/{manifest}</code>) and turns them into <code>BCC_</code> assets ( <code>UBeamContentCache</code> ) stored in <code>/Game/Beamable/Content/Manifests/Cooked/</code> directory.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/","title":"Microservices","text":"<p>Beamable Microservices are Beamable's Cloud Code solution. It is a wrapper around a HTTP Server that makes the development process much simpler. </p> <p>What languages can I write my Microservice in?</p> <p>At the moment, only <code>C#</code> Microservices are supported. But... that is likely to change in the future.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/#getting-started-with-c-microservices","title":"Getting Started with C# Microservices","text":"<p>To get started with Microservices in your project, you need a couple of things:</p> <ul> <li>Most Unreal <code>.[vcs]ignore</code> file templates will ignore all <code>*.sln</code> files. Instead of doing that, make sure to only ignore in the root directory with this  <code>/*.sln</code> instead of <code>*.sln</code>.<ul> <li>You can also just ensure your Microservice <code>.sln</code> is not ignored explicitly.</li> </ul> </li> <li>Ensure you have the Beamable CLI installed.</li> </ul> <p>Creating your first microservice will automatically create your solution for you. Following the guide below will generate the following recommended folder structure:</p> <pre><code>/repo-root\n|- ProjectName.uproject\n|- ProjectName.sln\n|- ProjectNameMS/\n|-- ProjectNameMS.sln\n|-- services/\n|--- MicroserviceName/\n|---- MicroserviceName.csproj\n</code></pre> <p>Open a terminal/shell at your project's root and run the following command to create a new project and add a new microservice. <pre><code>beam project new service MicroserviceName --sln ProjectNameMS/ProjectNameMS.sln\n</code></pre></p> <p>Then, run the following command to link the newly created project to your UE project. <pre><code>beam project add-unreal-project .\n</code></pre></p> <p>Linking a project informs the Microservice project that, whenever it recompiles the microservices, it  should re-generate a <code>ProjectNameMicroserviceClients</code> UE plugin inside your <code>Plugins/</code> directory. </p> <p>Add this plugin as a dependency to any project/plugin you have from which you want to make calls to your microservices (don't forget to add it to <code>Target.cs</code> files as needed). Call <code>ProjectNameMicroserviceClients.AddMicroserviceClients(this)</code> on any of the <code>Build.cs</code> files you have.</p> <p>Here are the constraints around these generated clients: - They follow the same pattern as our Auto-Generated UE APIs and are generated from the Microservice's OAPI docs.  - They'll ONLY generate types that are found in <code>[________Callable]</code> methods of your Microservices. - The generated Plugin is NOT editable by the user (it gets destroyed/recreated with every new generation). - In general, the type-mapping seen in the Content section is what you can expect.</p> <p>Customize the Generation?</p> <p>We do have plans to enable you to declare the intent to generate a particular type via an attribute in the future. However, actually customizing the outputted code is unlikely as it is already simple enough to write wrapper around it should you want a different style interface.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/#simple-example","title":"Simple Example","text":"<p>Here's the sample code for a simple microservice that adds two integers together: <pre><code>public class MSPlayground : Microservice  \n{  \n    [ClientCallable]  \n    public int Add(int a, int b)  \n    {\n        return a + b;  \n    }\n}\n</code></pre></p> <p>Here's how you'd call that endpoint from inside Unreal. <pre><code>// From inside any GameInstanceSubsystem, Actor or Component...\n\n// Get the Generated API subsystem\nconst auto MsApi = GEngine-&gt;GetEngineSubsystem&lt;UBeamMSPlaygroundApi&gt;();  \n\n// Create an instance of the generated Request object.\nUMSPlaygroundAddRequest* Req = UMSPlaygroundAddRequest::Make(1, 2, GetTransientPackage(), {});  \n\n// Declare the handler for the addition\nconst auto Handler = FOnMSPlaygroundAddFullResponse::CreateLambda([this](FMSPlaygroundAddFullResponse Resp)  \n{  \n    // If the request failed or we are retrying, we do nothing  \n    if (Resp.State != RS_Success)  \n       return;  \n\n    // Otherwise, print the value \n    UE_LOG(LogTemp, Display, TEXT(\"Microservice Add: %d\"), Resp.SuccessData-&gt;Value);\n});  \n\n// Make the request (the user slot will usually be the UBeamCoreSettings::GetOwnerPlayerSlot())\nFBeamRequestContext Ctx;  \nMsApi-&gt;CPP_Add(UserSlot, Req, Handler, Ctx, {}, this);\n</code></pre></p> <p>For more information on how to write microservice code itself, take a look at our SAMS C# Microservices docs.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/#libraries-and-c-microservices","title":"Libraries and C# Microservices","text":"<p>One of the big advantages of Beamable C# Microservices is that they are regular <code>.NET</code> projects. This means you get access to Nuget packages should you need to integrate beamable with any particular Third-Party technology that we don't support out-of-the-box.</p> <p>To do so, just use Nuget to add a package dependency to a project (this can be done easily through any IDE --- or through <code>dotnet nuget</code> command pallet).</p> <p>In other cases, you might have a couple of services that share some logic. To write your own shared code inside this solution, all you need to do is create a <code>dll</code> project by running the following command and the adding a reference to it in any of your Microservice's <code>.csproj</code> files.</p> <pre><code>// Run the command to create the library\nbeam project new common-lib LibraryName --sln ProjectNameMS/ProjectNameMS.sln\n\n// Add a reference to any Microservice's .csproj \n&lt;ProjectReference Include=\"..\\LibraryName\\LibraryName.csproj\"/&gt;\n</code></pre>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/#databases-microstorages","title":"Databases: MicroStorages","text":"<p>Beamable Microservices allow you to store data in Beamable's own managed services such as <code>Stats</code>(Per-Player key-value stores) and <code>Inventory</code> (Per-Player currency and item tracking). However, there are cases where you want to control your own data-model.</p> <p>For those cases, Beamable offers a <code>MicroStorage</code>. This is a wrapper around a database that you can write to from your microservices. At the moment, we only support <code>MongoDB</code> but that is likely to change in the future as more and more use-cases arise.</p> <p>To create a <code>MicroStorage</code>, run the command below. <pre><code>beam project new storage StorageName --sln ProjectNameMS/ProjectNameMS.sln \\\n  --link-to MicroserviceName\n</code></pre></p> <p>The <code>link-to</code> option will make the given Microservice depend on the newly created storage. </p> <p>Running Locally</p> <p>MicroStorages require you to ALWAYS have docker running when running locally. Microservices that DO NOT DEPEND on storages can be run directly from the IDE without docker running at all. Microservices that DO DEPEND on storages can also be run from the IDE, but docker MUST be running too.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/#development-workflow","title":"Development Workflow","text":"<p>Developing with microservices in Unreal is very straight forward:</p> <ol> <li>Make changes to your microservice code and rebuild it.<ol> <li>If we detect new or removed <code>______Callables</code>, we'll automatically run the Generate Project Files utility for you so your UE project is updated.</li> </ol> </li> <li>If needed, make changes to your client code to make use of the new <code>_____Callables</code>, clean up removed ones or modify code to use the new API for your microservice.</li> <li>Run the microservice locally through the IDE.</li> <li>Run Unreal and verifies that it works locally.</li> </ol> <p>You can just rinse-and-repeat the above until your logic is working locally.</p> <p>Before pushing this to a realm so others can access this and/or pushing it to your VCS, its is good practice to test the service inside the docker container. </p> <p>Why do I have to test things in docker?</p> <p>For most cases, you don't. For cases, where you manually edited the <code>.csproj</code> file and/or the <code>Dockerfile</code>, we recommend you do.</p> <p>To test your services locally but in Docker, run the following command with Docker running: <pre><code>beam services run\n</code></pre></p> <p>After the images boot up, you can open Unreal and test it normally. </p> <p>Minor Gotcha</p> <p>Remember to turn off the microservice running from the IDE. If you have both the IDE and the Docker version running locally, they'll both be trying to service requests which means that you'd be seeing them every request hit one of them at random.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/#deploying","title":"Deploying","text":"<p>Once you're satisfied with your service behavior and verified that its working, you can deploy it to a realm and test it.</p> <p>Which realm?</p> <p>How you wish to manage realms is a team-specific decision as there are cost implications per-microservice instance running in any realm to consider against how your team likes to work. At Beamable's UE team, we prefer the \"team members are responsible not to break other team members environment\"-approach so we recommend that you test things thoroughly and then push to your <code>dev</code> realm. Another strategy might be to have a <code>designer-dev</code> that lives between <code>staging</code> and <code>dev</code> that should be more stable and then you push to <code>dev</code> first and eventually promote it to <code>designer-dev</code>. Again, this is for your lead and team to discuss and decide how you wish to work.</p> <p>To deploy services to a realm, run the following command with docker running. <pre><code>beam services deploy\n</code></pre></p> <p>Beamable Microservices work through a declarative manifest. In less fancy terms, you give Beamable all services you have in your project and tell Beamable which of those services should be enabled or not. This information is defined in the <code>.csproj</code> files: <pre><code>&lt;BeamEnabled&gt;false&lt;/BeamEnabled&gt; to any of the services' `.csproj` &lt;PropertyGroup&gt;&lt;/PropertyGroup&gt; tags disables the service.\n\nNot having the &lt;BeamEnabled&gt;false&lt;/BeamEnabled&gt; implies that the service IS ENABLED.\n</code></pre></p> <p>The <code>beam services deploy</code> command will: - Figure out which services are enabled. - Figure out which services you deleted but were deployed at a certain point. - Build all images for which you have the source code and are enabled. - Upload these to Beamable's docker registry. - Build out the Manifest and ask Beamable to <code>Make it so</code>.</p> <p>The Beamable backend will read that new manifest and adjust, without downtime, the resources in the cloud to match that new manifest.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/#reverting-changes","title":"Reverting changes","text":"<p>Sometimes, mistakes happen. When they do and you need to revert changes, you can re-deploy an older manifest by doing the following: <pre><code>//Fetch an old manifest from the Portal (Operate -&gt; Microservices -&gt; Deployments)\nbeam project open-swagger MicroserviceName\n\n//Run this command\nbeam services deploy --from-file \"path/to/manifest.json\"\n</code></pre></p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/#how-many-microservices-is-too-many","title":"How Many Microservices is too many?","text":"<p>The first impulse a lot of people have is to separate microservices semantically; one-per-feature. We do not recommend this. Here's why:</p> <ul> <li>Having a lot of microservices will increase your cost for potentially no benefit.</li> <li>Having a lot of microservices increases deployment times.</li> <li>Having a lot of microservices increases project complexity.</li> <li>Having a lot of microservices makes you add latency to things that otherwise wouldn't have it (cross microservice communication is possible, but rarely actually needed).</li> </ul> <p>The key metric you should use to consider creating additional microservices is different load profiles at runtime. Basically, if you have a set of features with similar expected load profiles, you can keep them together as the auto-scaling will work uniformly to handle the increased load. If you have services with spikey load profiles, then consider putting each of them in their own service so that they can be scaled independently and faster (due to the smaller image size) than your other larger services.</p> <p>Game Maker: \"If I have 5 features in one microservices,  how do I organize my <code>____Callable</code> functions?\" Beamable: \"You can create add <code>partial</code> to your Microservice type and create other parts of it. You can declare utility static functions as well and make most <code>____Callable</code> just forward the call along.\"</p> <p>We've found these approaches gives you the proper runtime scalability for the lowest cost and provide a simple developer experience.</p>"},{"location":"Feature%20Guides/Unreal%20SDK%20-%20Microservices/#the-microservices-window","title":"The Microservices Window","text":"<p>This window is a read-only view into the state of your local services. It serves two purposes:</p> <ul> <li>It shows you which services are currently running locally and which aren't.<ul> <li>In other words, a quick panoramic view of your local microservice state.</li> </ul> </li> <li>It allows non-engineers to start up services from a UI window.<ul> <li>This is not a very common workflow as a lot of teams have designers/artists working in dedicated realms.</li> </ul> </li> </ul>"},{"location":"Samples/Unreal%20SDK%20-%20Hathora%20Demo/","title":"Hathora Demo","text":"<p>This demo, created from UE's FPS Template, show-cases how you can use the Unreal SDK, OnlineSubsystemBeamable and Beamable Microservices to integrate with Hathora (a game server orchestration provider).</p> <p>Aside from our <code>BeamableCore</code> Plugin and assets from the FPS Template, here's what the sample contains:</p> <ul> <li><code>BEAMPROJ_HathoraDemo</code> Unreal Plugin.: Contains the UE implementation for the game-server and client.</li> <li><code>Microservice/HathoraDemo</code> Microservice: Microservice containing code that ties Beamable's matchmaking system and Hathora's Game Server Orchestration system.</li> <li>Pre-Built Linux Dedicated Server Binaries: Building dedicated servers is time-consuming so... we give you a build that can be configured via Environment Variables so you can test the sample as fast as possible.</li> <li><code>OnlineSubsystemBeamable/Customer/**</code> Extension: Code added to the <code>OnlineSubsystemBeamable</code> plugin to extend our implementation of <code>IOnlineSubsystem</code> interfaces with code specific to the Hathora demo.</li> </ul> <p>To set up this sample you'll need a few things:</p> <ul> <li>A Beamable Account and a Realm.</li> <li>A Hathora Account.</li> <li>A downloaded build (link to git-hub action artifacts of release tag build).</li> </ul> <p>To configure the sample, set the <code>BeamProjOverride.txt</code> to <code>BEAMPROJ_HathoraDemo</code>, re-generate your project files and run the <code>BeamableUnreal</code> project (it'll be configured as the <code>BEAMPROJ_HathoraDemo</code> sample).</p>"},{"location":"Samples/Unreal%20SDK%20-%20Hathora%20Demo/#setting-up-beamable-hathora","title":"Setting up Beamable &amp; Hathora","text":"<p>Since this sample requires several resources, we do not host it ourselves. So, in order to access the sample you'll need to configure a Beamable realm so you can use it.</p> <ol> <li>Go to the Beamable Portal and create a new Beamable realm called <code>hathora-demo</code>.</li> <li>Go to the Portal (<code>Account</code>) and set aside your Customer Id (CID).</li> <li>Go to the Portal and set aside your realm's PID and Realm Secret (<code>Games -&gt; YourGame -&gt; hathora-demo</code>).</li> <li>Compile and open the <code>BeamableUnreal</code> editor (it'll be configured as the <code>BEAMPROJ_HathoraDemo</code>) project.</li> <li>Sign into your Beamable account and go to the <code>hathora-demo</code> realm.<ol> <li>Hit <code>Apply to Build</code>.</li> </ol> </li> <li>Open the <code>Content Window</code> -- verify that there are two <code>game_types</code>: <code>solo_queue</code> and <code>training</code>.<ol> <li>If you fail to see content here, close the editor and try again. There's a known issue in the UE SDK when accessing content for the first time that may cause them to not appear.</li> </ol> </li> <li>Hit <code>Publish</code> and wait. Go to the Portal (<code>Operate -&gt; Content</code>) and verify that the content is there.</li> <li>Open a bash terminal at the <code>BeamableUnreal</code> root directory.</li> <li>Make sure Docker is running and then run <code>beam services deploy</code> in that directory to get the microservices to your <code>hathora-demo</code> realm.</li> <li>Go to the Portal (<code>Operate -&gt; Microservices</code>) and verify that the microservices have initialized.</li> </ol> <p>Now, we'll go set up a Hathora account and upload the sample dedicated server build:</p> <ol> <li>Log into your Hathora account.</li> <li>Create an App and set aside its <code>AppId</code>.</li> <li>In the Hathora Portal, go to <code>Profile -&gt; Settings</code>.</li> <li>Create and set aside two dev-tokens: <code>game-server</code> and <code>matchmaking-server</code>.</li> <li>Deploy a new version by uploading the .tar file we provided for the sample.</li> <li>Set up the following environment variables with the values you set aside:<ol> <li><code>BEAMABLE_CUSTOMER_OVERRIDE</code> = <code>Your CustomerId (CID)</code></li> <li><code>BEAMABLE_REALM_OVERRIDE</code> = <code>Your hathora-demo Realm's PID</code></li> <li><code>BEAMABLE_REALM_SECRET</code> = <code>You hathora-demo Realm's Secret</code></li> <li><code>BEAMABLE_ENVIRONMENT_OVERRIDE</code> = <code>BeamProdEnv</code></li> <li><code>HATHORA_DEV_TOKEN</code> = <code>The game-server dev token</code>.</li> </ol> </li> <li>Make sure the <code>7777</code> UDP port is exposed.</li> <li>Make sure that the number of rooms per processes is <code>1</code>.</li> <li>Finish the deployment process and verify that the deployment was successful.</li> </ol> <p>Now that your Hathora account is configured to boot up our provided build, we need to configure the <code>hathora-demo</code> realm with the information it needs to correctly provision a server whenever a match is made.</p> <ol> <li>Go to the Beamable Portal and open the Realm Config page of the <code>hathora-demo</code> realm (<code>Operate -&gt; Config</code>).</li> <li>Hit the <code>Add Config</code> button.</li> <li>Set the following key-value pairs for the namespace <code>hathora_integration</code>.<ol> <li><code>app_id -&gt; Your Hathora AppId</code></li> <li><code>dev_token -&gt; Your matchmaking-server dev token</code> </li> </ol> </li> </ol> <p>Now, you are ready to join a match through PIE.</p>"},{"location":"Samples/Unreal%20SDK%20-%20Hathora%20Demo/#playing-the-sample-through-pie","title":"Playing the sample through PIE","text":"<p>In order to play the sample using a dedicated server in Hathora:</p> <ol> <li>Set your <code>Multiplayer Options -&gt; NetMode</code> to <code>Play as Standalone</code> and open the <code>Hathora Demo</code> map.<ol> <li>If you can't find it, turn on <code>Cotent Browser -&gt; Settings -&gt; Show Plugin Content</code> and look inside the <code>BEAMPROJ_HathoraDemo</code> content folder.</li> </ol> </li> <li>Run PIE.</li> <li>The first time you are running, type in an email/password and hit register. <ol> <li>In subsequent runs OR if you use the same email/password as your Beamable account, hit Login instead.</li> </ol> </li> <li>After you're signed in, hit the <code>Training</code> button and observe the logs. If you look at Hathora's Portal, you'll be able to see the server spinning up for you to play in. If you look at the your Microservice logs (<code>Operate -&gt; Microservice -&gt; HathoraDemo -&gt; Logs</code>), you'll be able to see its communication with Hathora.</li> <li>After a match is found --- 30 seconds later you'll connect to the actual server and see the match. </li> <li>Move around a while and then simply PIE.</li> </ol> <p>Cold Starts</p> <p>The first run of the application might time out due. If that happens, simply wait until you see a log line in the UE Log window that says \"DeleteTicket\" show up and simply re-join the queue.</p> <p>To test this out with two players (this is max players for this sample):</p> <ol> <li>Set your <code>Multiplayer Options -&gt; NetMode</code> to <code>Play as Client</code> and your <code>Multiplayer Options -&gt; Number of Players</code> to <code>2</code>.</li> <li>Sign into different accounts in each PIE instance.</li> <li>Hit the <code>Solo Queue</code> button instead of the <code>Training</code> one in both PIE instances.</li> <li>Wait for a bit and both PIE instances will be matched against each other.</li> </ol>"},{"location":"Samples/Unreal%20SDK%20-%20Hathora%20Demo/#what-can-you-do-with-this-sample","title":"What can you do with this sample?","text":"<p>This sample is NOT a template you can start your own repository from. </p> <p>However, its Beamable code components are free for you to copy and use in your own project. Here's what these are:</p> <ul> <li>The HathoraDemo Microservice.</li> <li>Beamable code inside <code>BEAMPROJ_HathoraDemo</code> except code inside a <code>ThirdParty</code> directory.</li> <li>Content inside the <code>BEAMPROJ_HathoraDemo</code> except things inside a <code>ThirdParty</code> directory.</li> </ul> <p>Why don't we provide a client build too?</p> <p>Because clients must be pointed at your <code>hathora-demo</code> realm. As such, you'd need to generate the build yourself, which you can do by packaging it normally for any of our supported platforms.</p>"},{"location":"Samples/Unreal%20SDK%20-%20Samples%20Intro/","title":"Samples Intro","text":"<p>Unreal Beamable Samples are distributed as a configuration of the Unreal SDK repository. We call these <code>BeamProj</code>. The <code>BeamProjOverride.txt</code> file at the root of the Unreal SDK project defines which of the <code>BEAMPROJ_</code> plugins is the active sample.</p> <p>To look at any given sample, you need to:</p> <ol> <li>Have our dependencies installed ( .NET and Docker)</li> <li>Clone our UnrealSDK repository and run the <code>init_repo.sh</code> script (we run it through GitBash but any shell should work).</li> <li>Change the contents of the <code>BeamProjOverride.txt</code> file to match the <code>BEAMPROJ_Plugin</code> of your choice. <ol> <li>For example, <code>BEAMPROJ_HathoraDemo</code> sets the repository as the Hathora Demo sample.</li> </ol> </li> <li>Generate Project Files.</li> <li>Open the solution and do a clean build of the editor.</li> <li>Open the editor and <code>Project Settings -&gt; Beamable Core -&gt; Beamable Environment</code> and set it to <code>BeamProdEnv</code> before signing into a Beamable account.</li> </ol> <p>Further instructions for seeing each sample can be found in their respective sample docs.</p> <p>Why not a separate repository?</p> <p>Workflow is important to us. We want to maintain these sample projects over the long run as a means to dogfood our own tools. So... our samples are part of our repo to minimize developer friction which translates to up-to-date samples and better stability for our product.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Dedicated%20Servers/","title":"Dedicated Servers","text":""},{"location":"Use%20Guide/Unreal%20SDK%20-%20Intro/","title":"Getting Started","text":""},{"location":"Use%20Guide/Unreal%20SDK%20-%20Intro/#getting-started","title":"Getting Started","text":"<p>Before you can start using Beamable in your project, sign-up in our portal. </p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Intro/#requirements-for-beamable","title":"Requirements for Beamable","text":"<p>Beamable currently supports Unreal 5.3.2.</p> <p>Beamable also has a dependency on  .NET Version 8.0. This is needed for:</p> <ul> <li>Installing the Beamable CLI (and therefore enabling the various Beamable workflows).</li> <li>Using C# Microservices through the CLI.</li> </ul> <p>Beamable has a hard-dependency on Docker. This is needed for two things:</p> <ul> <li>Building and Deploying Beamable Microservices to your realms (dev/staging/prod environments).</li> <li>Running Beamable Microservices without opening the service's project (for non-engineers that want to run microservices locally).</li> </ul> <p>If you don't have these installed, take this opportunity to install them.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Intro/#cloning-and-installing-dependencies","title":"Cloning and Installing Dependencies","text":"<p>Start by getting our repo, then installing .NET and Docker Dekstop.</p> <ol> <li>Clone UnrealSDK repo (make sure you have git and <code>git-lfs</code> installed).</li> <li>Checkout the tagged release version from the <code>main</code> branch you wish to use (tag format is a semantic version).</li> <li>Run the <code>init_repo.sh</code> script.<ol> <li>It installs the correct Beamable CLI version globally for you).</li> <li>It also sets up this repo so you can look at our samples.</li> </ol> </li> <li>Optional - Generate Project Files. <ol> <li>On Windows, you can right-click the <code>.uproject</code> file and select <code>Generate Visual Studio project files</code>.</li> </ol> </li> <li>Optional - Verify things are working by compiling the editor of our SDK project.</li> </ol> <p>Once you have our repo and dependencies set up in your machine, follow along one of the next section to set up the SDK in your project.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Intro/#set-up-the-beamable-sdk-fast-path","title":"Set up the Beamable SDK - Fast Path","text":"<p>Setting up the SDK in your project is done by manually copying over a set of files from our Unreal SDK repo to your project. </p> <p>Unreal Project Requirements</p> <p>Beamable requires your Unreal project to be a C++ project. That being said, we do provide an entire suite of Blueprint nodes that can be used to achieve most of the same functionality.</p> <p>Please, follow along these instructions:</p> <ol> <li>Copy the <code>beam_init_game_maker.sh</code> script into the root of your Unreal Project.</li> <li>Copy the <code>UnrealSDK/Plugins/BeamableCore</code> plugin into your <code>Plugins</code> folder.</li> <li>Add  <code>{ \"Name\": \"BeamableCore\", \"Enabled\": true }</code> to the array of <code>Plugins</code> in your project's <code>.uproject</code> file.</li> <li>Open the <code>UnrealSDK/Source/BeamableUnreal.Target.cs</code> file and copy the <code>Beam</code> class into your <code>YourGame.Target.cs</code> file.<ol> <li>Add a <code>using System;</code> line to your using statements in <code>YourGame.Target.cs</code>.</li> </ol> </li> <li>For each existing <code>Target.cs</code> file (if one doesn't exist, just don't add it), call the corresponding function in its constructor.<ol> <li><code>YourGame.Target.cs</code> =&gt; <code>Beam.ConfigureGame(this, default);</code></li> <li><code>YourGameEditor.Target.cs</code> =&gt; <code>Beam.ConfigureEditor(this, default);</code></li> <li><code>YourGameServer.Target.cs</code> =&gt; <code>Beam.ConfigureServer(this, default);</code></li> </ol> </li> <li>For each existing Beamable-dependent Module (if one doesn't exist, just don't add it), add a function call to its <code>Build.cs</code> file (see the type of module inside your <code>uproject</code> file):<ol> <li>Runtime Modules =&gt; <code>Beam.AddRuntimeModuleDependencies(this);</code></li> <li>UncookedOnly Modules =&gt; <code>Beam.AddUncookedOnlyModuleDependencies(this);</code></li> <li>Editor Modules =&gt; <code>Beam.AddEditorModuleDependencies(this);</code></li> </ol> </li> <li>Run the <code>YourProject/beam_init_game_maker.sh</code> script from inside your project's root directory.<ol> <li>This will install the version of our CLI tool that your SDK version corresponds to locally in your project.</li> <li>Verify that it worked by running <code>dotnet beam --version</code> from inside your project root directory.</li> </ol> </li> <li>Generate Project Files for your project. <ol> <li>On Windows, you can right-click the <code>YourGame.uproject</code> file and select <code>Generate Visual Studio project files</code>.</li> </ol> </li> <li>Open Rider/VS and compile your editor.</li> </ol>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Intro/#making-your-first-request","title":"Making your First Request","text":"<p>Once your Editor opens, you'll see the Beamable Logo in your upper-right bar, next to the Settings dropdown. This button opens the Beamable window.</p> <p></p> <p>In this window, you can login to the account you just created in the Beamable portal. When you do, you should see the window below:</p> <p></p> <p>Here's some a quick tour of Beamable terminology:</p> <ul> <li><code>Realm</code> is an isolated data environment (think of it as a branch, but for your backend). <ul> <li>By default, you have one of these these for your <code>dev</code>, <code>staging</code> and <code>prod</code> environments.</li> <li>The <code>ApplyToBuild</code> button sets the realm information in the <code>Config/DefaultEngine.ini</code> file of your project. Whatever realm is configured in this file, is the realm your build will be pointed towards. Dedicated Server Builds don't need to care about their baked in <code>TargetRealm</code>. They fetch their target realm from Environment Variables.</li> </ul> </li> <li><code>Content</code> opens up the Content Window.  See the Content Docs for more info.</li> <li><code>Open Portal</code> opens the Portal in your default web-browser already logged in with your editor user and pointed at your current realm.</li> <li><code>Microservices</code> opens the Microservice Window. See the Microservice Docs for more info.</li> <li><code>Reset PIE Users</code> (Play-In-Editor) removes your PIE users locally cached data. <ul> <li>By default, when you sign into a Beamable account in PIE (in your game code), Beamable will use the same user until you delete the files <code>Saved/Beamable/UserSlots/PIE_XXXXX.json</code>. This button does that for you. After you click it, the next time you enter PIE, a brand new Beamable player account will be created in your current realm.</li> </ul> </li> </ul> <p>Now that you are familiar with the Beamable Window, you are ready to make your first Beamable request (we'll do it via Blueprint, but you can do the exact same flow in C++ by making these calls in your Project's <code>GameMode</code> class's <code>BeginPlay</code> function).</p> <p>To get started, open your Level Blueprint and add the following pattern:</p> <p></p> <p>The <code>BeamRuntime</code> is an <code>GameInstanceSubsystem</code> that is responsible for controlling the SDK's lifecycle and, in clients, player authentication. </p> <p>Runtime Concepts Guide</p> <p>The Runtime Concepts Guide explains how the Beamable Runtime works. Please read it after you are done with this guide as the default Beamable configuration might not be the best fit for your type of game and it'll give you examples of common setups.</p> <p>Now that you have this event hooked up, you can add your first Beam Flow Node. These nodes are custom nodes that wrap around the following functionality:</p> <ul> <li>Creating a new Request <code>UObject</code>.</li> <li>Getting a <code>UBeam___Api</code> engine subsystem. <ul> <li>This is a stateless system that exposes an auto-generated API to talk to various services.</li> <li>This is not the recommended way you'll use Beamable. Its just the simplest way for you to get started.</li> </ul> </li> <li>A set of Custom Event nodes (for success, error and completion) of the request being made to the Beamable backe-end.<ul> <li>Because of this, Unreal does not allow the use of these nodes (or any node that expands to Event nodes) outside of EventGraphs or Macros used in EventGraphs.</li> </ul> </li> </ul> <p></p> <p>With the SDKs default configuration and the above setup, you can enter PIE (Play-In-Editor). You should see several requests's responses being written to your Output Log window. After you see the final <code>GetMe</code> request, you can exit PIE knowing you've very first request to the Beamable backend.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Intro/#additional-information","title":"Additional Information","text":"<p>Before we complete this guide, there's one final thing that is important to know. You can, and should, use verbose logging <code>log \"Category\" Verbose</code> when you encounter an issue stemming from our SDK (Log Categories can be found in <code>BeambleCore/BeamLogging.h</code> file). </p> <p>This verbose logging will print out everything about the request being made. Its meant to aid us in diagnosing issues that you may encounter when using the SDK AND not for production use. To turn it off in the same editor session, just run <code>log LogBeamBackend Display</code> in the editor console.</p> <p>When reporting an issue, try to reproduce the issue with the logs of the relevant systems set to Verbose and attach them to the issue.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Intro/#next-steps","title":"Next Steps","text":"<p>Now that you've made your first Beamable Request, take a look at the Unreal SDK - Runtime Concepts page so you understand more about how the SDK is structured and the various paths to using it and the best path for your game.</p> <p>If you'd like to see a more complicated example running on Beamable, take a look at our Samples.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Operations%20%26%20Waits/","title":"Operations & Waits","text":""},{"location":"Use%20Guide/Unreal%20SDK%20-%20Operations%20%26%20Waits/#unreal-sdk-operations-waits","title":"Unreal SDK - Operations &amp; Waits","text":"<p>The Beamable SDK uses slight variation on Promises we named Operations. These provide the same semantics as promises but their implementation is slightly different to allow for a BP-compatible API.</p> <p>They wrap concurrent operations (mostly HTTP Requests) under a <code>FBeamOperationHandle</code> exposed to some higher-level system. To put it in simpler terms:</p> <p>When you want to expose a single function that makes a bunch of requests and emits events as responses come in, ultimately handling success/failure of the entire sequence, use an Operation.</p> <p>We provide a lot of Operations inside our <code>UBeamRuntimeSubsystem</code> implementations; covering most basic use-cases. However, understanding how to create your own operations enables you to add behavior to last-mile hooks we expose. A couple of examples:</p> <ul> <li>\"I want to go talk to a microservice to fetch additional data for a user before you trigger the <code>OnBeamableReady</code> callback.\"</li> <li>\"I want to go talk to a microservice to validate that you can actually join this matchmaking queue.\"</li> </ul> <p>Warning</p> <p>While possible, we don't recommend creating the actual operations as blueprints. Its OK to do so for a quick experimentation session; but shipping with it is not recommended. Calling Operations that are written in C++ is the primary way we recommend Blueprints to interact with the Beamable SDK (we even have special nodes for it). </p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Operations%20%26%20Waits/#operation-lifecycle","title":"Operation Lifecycle","text":"<p>Every Operation has an <code>int64</code> id called the <code>FBeamOperationHandle</code>. We use it to track the operation's state, its emitted events, its current status and which of Beamable's requests are part of it, so on and so forth...</p> <p>The lifecycle of an operation goes as follows:</p> <ol> <li>Create it with calls to <code>[CPP_]BeginOperation</code> passing in an <code>FBeamOperationEventHandler[Code]</code>.<ol> <li>The event handler is called whenever any event of any type is triggered; the <code>FBeamOperationEvent</code> struct has data in it useful for deciding how to respond to the event.</li> </ol> </li> <li>Its status stays as <code>ONGOING</code> until <code>UBeamRequestTracker</code>'s <code>TriggerOperationSuccess</code>, <code>TriggerOperationError</code> or <code>TriggerOperationCancelled</code> functions are called with the created <code>FBeamOperationHandle</code> and, optionally, some <code>FString</code> data.<ol> <li>While its <code>ONGOING</code>, you can make calls to <code>TriggerOperationEvent</code> passing in any <code>SubEvent</code> other than <code>NAME_None</code>. This triggers an event that will call the Operation's <code>FBeamOperationEventHandler[Code]</code> but will not change its status.</li> <li><code>TriggerOperationSuccess</code>, <code>TriggerOperationError</code> and <code>TriggerOperationCancelled</code> are just wrappers around <code>TriggerOperationEvent</code> with a <code>SubEvent == NAME_None</code>.</li> </ol> </li> <li>Once a final event (any event with <code>SubEvent == NAME_None</code>) is triggered, the Operation is completed and its <code>FBeamOperationEventHandler[Code]</code> runs a final time.</li> <li>The Operation is not cleaned up while other Operations or Waits (see <code>[CPP_]WaitAll</code>) depend on it.<ol> <li>Every now and again we clean them up in a tick functions with low tick rate (check <code>UBeamRequestTracker</code> for more information).</li> </ol> </li> </ol>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Operations%20%26%20Waits/#writing-and-exposing-your-own-operations","title":"Writing and Exposing your Own Operations","text":"<p>We try and expose all of our main SDK operations in both BP and CPP flavors. If you'd like to do the same thing, this section is for you. If you're looking for how to write hooks in C++, look into the next section.</p> <p>The primary trade-off is that: BP-Compatible versions do not allow for lambda binding and variable capturing. The CPP Version does allow for those things and, as they can be extremely useful for development speed and other cases, we decided on supporting both flavors.</p> <p>The snippet below explains how to write an operation for both BP and CPP; sharing its actual logic. </p> <pre><code>// This is the BP-Compatible Function\nFBeamOperationHandle U________::__________Operation(FUserSlot UserSlot, (...OperationParams...), FBeamOperationEventHandler OnOperationEvent, UObject* CallingContext)  \n{  \n    // First, we start an operation using the BP-Compatible BeginOperation call\n    const auto Handle = Runtime-&gt;RequestTrackerSystem-&gt;BeginOperation({UserSlot}, GetClass()-&gt;GetFName().ToString(), OnOperationEvent);  \n\n    // Then, we call a function that takes in the operation parameters and the Handle for the operation.\n    TheActualOperationLogic(UserSlot, (...OperationParams...), Handle);  \n\n    // Operation functions usually return the handle so that callers can ask questions about the state of the operation if they want to.    \n    return Handle;  \n}  \n\n// This is the CPP Function\nFBeamOperationHandle U__________::CPP_________Operation(FUserSlot UserSlot, (...OperationParams...), FBeamOperationEventHandlerCode OnOperationEvent, UObject* CallingContext)  \n{  \n    // First, we start an operation using the BP-Compatible BeginOperation call\n    const auto Handle = Runtime-&gt;RequestTrackerSystem-&gt;CPP_BeginOperation({UserSlot}, GetClass()-&gt;GetFName().ToString(), OnOperationEvent);  \n\n    // Then, we call a function that takes in the operation parameters and the Handle for the operation.\n    TheActualOperationLogic(UserSlot, Key, Value, Handle);  \n\n    // Operation functions usually return the handle so that callers can ask questions to UBeamRequestTracker about the state of the operation if they want to. \n    return Handle; \n}\n\n\nvoid U__________::TheActualOperationLogic(FUserSlot Slot, (...OperationParams...), FBeamOperationHandle Op)  \n{  \n    // This is mostly an example snippet of things you can do...\n\n    // We can check the local client state and fail operations without any request ever being made.\n    // For example, check if a user is authenticated or not.\n    FBeamRealmUser RealmUser;  \n    if (!UserSlots-&gt;GetUserDataAtSlot(Slot, RealmUser, this))  \n    {       \n    RequestTracker-&gt;TriggerOperationError(Op, TEXT(\"NO_AUTHENTICATED_USER_AT_SLOT\"));  \n    return;  \n    }  \n\n    // We can also prepare a request handler, capturing the \"Op\" Handle\n    const auto SomeRequestHandler = FOn______::CreateLambda([this, Op](F______ Resp)  \n    {  \n\n        // If the request is being retried, we don't do anything.\n        // But... we could go update a UI here or something...\n        if (Resp.State == RS_Retrying) return;\n\n        // If the request was successful, we can trigger the Operation as a success.\n        if (Resp.State == RS_Success)  \n        {\n            // (...) change local system's state            \n            RequestTracker-&gt;TriggerOperationSuccess(Op, {});  \n        }\n        // If the request failed, we can trigger the Operation as a success.\n        else \n        { \n            // (...) handle error and trigger the Operation as an error.\n            RequestTracker-&gt;TriggerOperationError(Op, Resp.ErrorData.error); \n        }\n    });    \n\n    // Make the request passing in the \"Op\" Handle (this tracks lets our UBeamBackend know not to clean up the request until the Operation has finished)\n    auto Ctx = Request____(Slot, (...ReqParams...), Op, SomeRequestHandler);\n}\n</code></pre> <p>Warning</p> <p>The parameter names <code>UserSlot</code>, <code>OnOperationEvent</code> and <code>CallingContext</code> are important! They allow you to write your own implementation of our Beam Flow node for your operation. Look at the Beam Flow Nodes section for more information on how to create these.</p> <p>There are ton of examples of operations in our SDK. For some guidance, you can take a look at any of our various runtime subsystems such as:</p> <ul> <li><code>UBeamStatsSubsystem</code></li> <li><code>UBeamInventorySubsystem</code></li> <li><code>UBeamLobbySubsystem</code></li> <li>Any other sub-class of <code>UBeamRuntimeSubsystem</code>.</li> </ul> <p>Feel free to copy-paste them as a template of how to implement and reason about <code>Operations</code>.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Operations%20%26%20Waits/#beam-flow-nodes-operations","title":"Beam Flow Nodes - Operations","text":"<p>Beam-Flow nodes are the purple nodes with Beamable Icons that you can find. There are two flavors of them; one are Raw Requests that you can use to hit our APIs; the other is the Operation Beam Flow node.</p> <p></p> <p>Beamable Operation Flow Nodes assume a few things:</p> <ul> <li>There's some number of participating <code>UserSlots</code> .</li> <li>There's an event handler that'll handle the three types of events: <code>OET_SUCCESS</code>, <code>OET_ERROR</code> and <code>OET_CANCELLED</code>.</li> <li>There's some <code>FString</code> data associated with each of those events.</li> </ul> <p>To create these nodes for your own operations, you can look at any of our own nodes (that live inside our <code>UncookedOnly</code> module: <code>BeamableCoreBlueprintNodes</code> ) and copy/paste one implementation changing the values accordingly. </p> <p>Restrictions on exposing <code>UFUNCTIONs</code> with these nodes:</p> <ul> <li>The function must be declared from inside a <code>UGameInstanceSubsystem</code> / <code>UBeamRuntimeSubsystem</code> subclass.</li> <li>The function must be a <code>UFUNCTION</code> that returns a <code>FBeamOperationHandle</code>.</li> <li>The signature must contain the following named parameters:<ul> <li><code>FUserSlot UserSlot</code>, if a single user is involved in the operation, or <code>TArray&lt;FUserSlot&gt; UserSlot</code>, if multiple users are involved in the operation.</li> <li>If multiple users, the <code>UFUNCTION</code> must also add <code>meta=(BeamOperationMultiUser)</code>.</li> <li><code>FBeamOperationEventHandler OnOperationEvent</code> to be the event handler that will handle all events raised by the operation.</li> </ul> </li> <li>The function can have any other parameters you want in any order as long as the above parameters are there.</li> </ul> <p>Here's an example of what you need to declare one of these.</p> <pre><code>#define LOCTEXT_NAMESPACE \"K2BeamNode_Operation_CommitInventoryUpdate\"  \n\nUCLASS(meta=(BeamFlowNode))  \nclass UK2BeamNode_Operation_CommitInventoryUpdate : public UK2BeamNode_Operation  \n{  \n    GENERATED_BODY()  \n\n    // This returns the title of the node.\n    virtual FText GetNodeTitle(ENodeTitleType::Type TitleType) const override { return LOCTEXT(\"Title\", \"Operation - Inventory - CommitInventoryUpdate\"); }  \n\n    // This should get a static UFUNCTION that returns a valid instance of the UGameInstanceSubsystem containing the Operation function.\n    virtual FName GetSubsystemSelfFunctionName() const override { return GET_FUNCTION_NAME_CHECKED(UBeamInventorySubsystem, GetSelf); }  \n\n    // This should return the UFUNCTION Operation's name.\n    virtual FName GetOperationFunctionName() const override { return GET_FUNCTION_NAME_CHECKED(UBeamInventorySubsystem, CommitInventoryUpdateOperation); }  \n\n    // This should get the UGameInstanceSubsystem class\n    virtual UClass* GetRuntimeSubsystemClass() const override { return UBeamInventorySubsystem::StaticClass(); }  \n\n};  \n\n#undef LOCTEXT_NAMESPACE\n</code></pre> <p>As long as you have one of these in an <code>UncookedOnly</code> module of your application, you should be able to expose your own operations as BP nodes (this is compatible with Multiplayer PIE mode).</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Operations%20%26%20Waits/#writing-hooks","title":"Writing Hooks...","text":"<p>... and other <code>FBeamOperationHandle</code> returning functions. These are the various callback flavors that we expose so you can customize your experience with our SDK. In other words:</p> <p>If you ever see a Delegate or Virtual Function that you can implement that returns one or more <code>FBeamOperationHandle</code>, you need to create operations and return their handles so that we can wait on your code before we proceed with ours.</p> <p>Here are the flavors:</p> <ol> <li>Delayed Operation: Its basically a simple parameterless callback that returns a <code>FBeamOperationHandle</code> our SDK should wait for.<ol> <li>See our various <code>UBeamRuntime::LoginGuest</code> functions for an example on how to use these in your own code.</li> </ol> </li> <li>Runtime Subsystem Implementation: Implementations of virtual functions in one of our SDK's base classes such as <code>UBeamRuntimeSubsystem</code>.<ol> <li>This is for when you wish to make a system that ties into the Beamable life-cycle like our own systems do.</li> <li>This is rarely needed, but... in custom enough use-cases, its likely to be the best way to accomplish your goals.</li> </ol> </li> <li>Hooks:  Hook into one of the various  <code>DEFINE_BEAM_OPERATION_HOOK</code> hooks.<ol> <li>We don't use Hooks ourselves IN ANY CIRCUNSTANCES and leave these as \"game-maker-only extensions\".</li> <li>You can search for <code>DEFINE_BEAM_OPERATION_HOOK</code> and find some usages of the macro to better understand these. </li> </ol> </li> </ol>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Operations%20%26%20Waits/#beam-operation-hooks","title":"Beam Operation Hooks","text":"<p>Hooks have some more context that you should know about how to use them:</p> <ol> <li>You call some Operation we expose in our SDK. That Operation does a bunch of things and triggers the hooks at some well-known point during their execution.<ol> <li>Since you have the source code, you can look into these functions and see the exact semantics of the trigger but we do try and keep these documented in call-site comments.</li> </ol> </li> <li>Triggering the hooks mean:<ol> <li>The returned <code>FBeamOperationHandles</code> from the hooks are fed into  <code>UBeamRequestTracker::WaitAll</code>.</li> <li>Our operation will wait for all your hooks to complete; successfully or otherwise.</li> <li>If your registered operations fail, we'll log out the errors that exist inside that operation and let you know clearly the problem happened in the operation you provided to the hook.</li> <li>If your operations succeeded, we'll continue with our own operation and eventually trigger that as a success.</li> <li>The semantics of what happens in case of a failure change from hook to hook, but... for the most part, we'll fail our own operation if any hooks fail.</li> </ol> </li> </ol> <p>Here's a \"template example\" of how this stuff will typically look like:</p> <pre><code>// Let's say you want to run some synchronous code at a hook but don't really want to make any request to anything.\n// In that case you can get the system and add a hook that:\nconst U_____ SomeSystem;  \nSomeSystem-&gt;Hook.Add(F____::CreateLambda([this]()  \n{  \n    // (...) Does some synchronous code\n    // This means that your operation is completed at the end of this function\n\n    // For cases like these, we provide the utility function below.\n    // This creates and immediately completes an operation and returns its handle.\n    return GEngine-&gt;GetEngineSubsystem&lt;UBeamRequestTracker&gt;()-&gt;CPP_BeginSuccessfulOperation({}, FString(\"MySystemName\"), FString(\"\"), FBeamOperationEventHandlerCode{});  \n}));  \n\n// Let's say you want to call some microservice you wrote as part of our operation\n// In that case you can add a hook that:\nSomeSystem-&gt;Hook.Add(F____::CreateLambda([this]()  \n{  \n    // Begins an operation\n    const auto Op = GEngine-&gt;GetEngineSubsystem&lt;UBeamRequestTracker&gt;()-&gt;CPP_BeginOperation({}, FString(\"MySystemName\"), {});\n\n    // Get Microservice Subsystem that exposes calls to it\n    const auto MyMsApi = GEngine-&gt;GetEngineSubsystem&lt;UMyMsApi&gt;();  \n    const auto MyMsReq = UMyMsRequest::Make(GetTransientPackage(), {});  \n\n    // Create the handler for the request capturing the \"Op\" its a part of.\n    const auto MyMsHandler = FOnMyMsFullResponse::CreateLambda([this, Op](FMyMsFullResponse Resp)  \n    {       \n        // If we timedout and are retrying the request, do nothing.\n        if(Resp.State == RS_Retrying)  \n            return;         \n\n        UE_LOG(LogTemp, Display, TEXT(\"Talked to a Microservice from a Hook!!!! Look at that, huh?\"));  \n\n        // If the response from the Microservice was not a success, fail the operation.\n        if(Resp.State != RS_Success)  \n        {   \n            // Trigger the operation as a success\n            GEngine-&gt;GetEngineSubsystem&lt;UBeamRequestTracker&gt;()-&gt;TriggerOperationError(Op, Resp.ErrorData.message);  \n            return;  \n        }  \n\n        // (...) Do stuff with the Microservice's response\n\n        // Trigger the operation as a success\n       GEngine-&gt;GetEngineSubsystem&lt;UBeamRequestTracker&gt;()-&gt;TriggerOperationSuccess(Op, FString(\"\"));  \n    });   \n\n    // Make the request\n    FBeamRequestContext Ctx;  \n    MyMsApi-&gt;CPP_MyMs(UserSlot, MyMsReq, MyMsHandler, Ctx, Op, GetGameInstance());  \n\n    // Return the create Operation\n    return Op;  \n}));\n</code></pre>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Operations%20%26%20Waits/#why-not-promises","title":"Why not Promises?","text":"<p>The biggest reason not to do that is Blueprint Compatibility. The most recognizable template-based Promise-style API just won't work with BPs. As such, we wanted to create a underlying system that was a superset of that style of API but that retained BP compatibility even if it lost the template-based interface.</p> <p>The result was this Operation system.</p> <p>Info</p> <p>In using it inside our own SDK to develop our Stateful <code>UBeamRuntimeSubsystems</code>, we found that we didn't miss the template aspect or its chaining aspect of <code>Do().Then()</code>. However, the chaining might be something we eventually look into. Perhaps adding the ability to chain requests like these as \"syntactic sugar\"; but its highly unlikely we'll do anything with templates at the Operation-layer as we do not want to lose the BP-Compatibility.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Runtime%20Concepts/","title":"Runtime Concepts","text":""},{"location":"Use%20Guide/Unreal%20SDK%20-%20Runtime%20Concepts/#unreal-sdk-runtime-concepts","title":"Unreal SDK - Runtime Concepts","text":"<p>The Beamable SDK is a collection of custom UE Engine, Editor and GameInstance Subsystems. Game-Maker Code (as in, code the Beamable customer writes) can take advantage of various guarantees we provide by understanding how these subsystems work.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Runtime%20Concepts/#ubeamuserslots-and-fuserslot","title":"UBeamUserSlots and FUserSlot","text":"<p>Inside the Beamble SDK, the concept of a <code>UserSlot</code> represents a named \"local player\" slot. By default, we ship with two lists of User Slots inside the <code>UBeamCoreSettings</code>(found in <code>Project Settings -&gt; Engine</code>) :</p> <ul> <li>The <code>RuntimeUserSlots</code> , that contains a default slot at index 0, called <code>Player0</code>. <ul> <li>This list is the list of expected player slots for every running client of your game.</li> </ul> </li> <li>The <code>EditorUserSlots</code>, that contains a default slot at index 0, called <code>MainEditorDeveloperSlot</code>. <ul> <li>The Beamable Editor integration also uses the user slot system to authenticate the requests it makes to the Beamable servers. So... when you signed into the editor, you're data is associated to this default slot.</li> </ul> </li> </ul> <p>The point of this is to allow our SDK to be compatible with local co-op games that also want to make use of Beamable features with per-player granularity. As in, allow local players 1 and 2 to log into their respective accounts. This is also what enables our Multiplayer PIE-mode integration.</p> <p>The <code>UBeamUserSlots</code> Engine Subsystem is responsible for:</p> <ul> <li>Namespacing slots to support Multiplayer PIE-mode. This is why, like UE, we take in a <code>UObject* CallingContext</code> in certain parts of our APIs.</li> <li>Assert that only slots defined in the <code>UBeamCoreSettings</code> are in use. <ul> <li>Any User Slot with <code>Test</code> in its name is exempt from this rule so you can write automated tests with arbitrary amounts of user slots by using user slots with <code>Test</code> in their names.</li> </ul> </li> </ul> <p>This subsystem does not handle the actual logging in and logging out. That is handled by two other Subsystems:</p> <ul> <li><code>UBeamRuntime</code> , a <code>GameInstanceSubsystem</code>, is responsible for PIE instances and packaged games. </li> <li><code>UBeamEditor</code>, an <code>EditorSubsystem</code>, is responsible for the Editor integration.</li> </ul>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Runtime%20Concepts/#ubeamruntime-ubeamruntimesubsystem","title":"UBeamRuntime &amp; UBeamRuntimeSubsystem","text":"<p><code>UBeamRuntime</code> is the entry point for the Beamable SDK at runtime. It is a <code>GameInstanceSubsystem</code> and follows its lifecycle rules. It is responsible for a couple of things:</p> <ul> <li>It controls the SDK's runtime initialization flow.</li> <li>It controls the various SDK's user [un]-authentication flows.</li> <li>It controls <code>UBeamRuntimeSubsystems'</code> lifecycle with respect to the SDK itself and <code>FUserSlots</code>.</li> </ul> <p>The image below describes how the SDK's lifecycle injects itself into UE's lifecycle:</p> <p></p> <p>The next image show a high-level description of the authentication flows supported by the SDK:</p> <p></p> <p>Now that you have a high-level understanding of the SDK's initialization flows, read up on how to achieve the two most common Sign Up and Login flows among the ones we provide.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Runtime%20Concepts/#player-sign-up-and-login-flows-with-beamable","title":"Player Sign Up and Login Flows with Beamable","text":"<p>The Beamable SDK comes with a set of pre-implemented operations for common sign-up use-cases. Here are how to set up a few of the common login/signup flows using Beamable.</p> <p>Mobile and Console Support</p> <p>We DO NOT provide mobile support yet. This version of the SDK is focused on PC (Windows/Linux) and Dedicated Servers. Console and Mobile support will be added later.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Runtime%20Concepts/#login-flow-mobile-games-style-authentication","title":"Login Flow - \"Mobile Games\" Style Authentication","text":"<p>By default, the SDK comes configured with Frictionless Authentication turned on. This is to make testing easier and allow for easy experimentation.</p> <p>In this mode, after <code>UBeamRuntime::OnStarted</code> has run, we'll automatically login a <code>guest</code> user, at the first configured <code>FUserSlot</code>. If an account is already locally cached at that <code>FUserSlot</code> we'll login to that one automatically.</p> <p>Handling Errors in Frictionless Authentication</p> <p>At the moment, there's not much automatic error handling for this path and we don't recommend shipping with it on for now (its mostly there to make it easy to get started and experiment with the SDK).</p> <p>With Frictionless Auth turned on, you can add delegates to <code>UBeamRuntime::OnUserReady</code> from any <code>GameInstanceSubsystem</code> or from <code>BeginPlay</code> callbacks and start using the SDK there as a <code>guest</code> Beamable user. Guest users will be lost if signed out (or have its locally cached data lost for any reason). </p> <p>To avoid losing guest user data, players can to \"attach\" some persistent identity information to that guest user. Call the various <code>UBeamRuntime::Attach_____</code> Operations to do that. After a successful attach call, a player will be able to login via the corresponding <code>UBeamRuntime::Login____</code> operation. For example, if you <code>AttachEmailAndPassword</code> you'll be able to <code>LoginEmailAndPassword</code> to sign back into the account.</p> <p>By default, this does not run in Dedicated Servers even if it is on. Dedicated Servers use a different form of authentication that is not based on <code>FUserSlots</code>.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Runtime%20Concepts/#login-flow-pcconsole-style-authentication","title":"Login Flow - \"PC/Console\" Style Authentication","text":"<p>In PC/Console titles, often the user can sign-in and up from inside the game. That can happen either through an active form-filling process, an active request to third-party authentication (Discord, Google, etc...) or an automatic store-based login (Epic Online Services, PSN, Steam, etc...). </p> <p>If your game has these flows, we recommend you disable frictionless auth and manage the login/signup flows in your game code. The steps below explain how to do that.</p> <p>Start by turning off Frictionless Authentication in <code>Project Settings -&gt; Beamable Core -&gt; Authenticate Frictionless (...)</code>.</p> <p></p> <p>Next, in your <code>BeginPlay</code> implementation, register a function to run when the SDK has successfully started via <code>UBeamRuntime::RegisterOnStarted</code>. If the SDK has already started when you call this function, it'll run the callback you provide it as its parameter immediately; if not, it'll wait until the SDK is fully ready and then call it. </p> <p><code>RegisterOnStarted</code> and <code>RegisterOnReady</code></p> <p>Remember that these are part of the initialization flow. As such, try to have a single function bound to these points in order to provide guarantees to the rest of your game code about the state of Beamable.</p> <p>At any point during or after that callback has triggered, make a call to one of the <code>UBeamRuntime::SignUp____</code> or <code>UBeamRuntime::Login____</code> Operations with the appropriate parameters. We treat these operations as atomic inside the SDK and will clear any invalid partial state in case of any failure during their internal multi-step process; triggering <code>UBeamRuntime::OnUserReady</code> only in the case that the user is fully ready for use.</p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Runtime%20Concepts/#understanding-beamruntimesubsystems","title":"Understanding BeamRuntimeSubsystems","text":"<p><code>BeamRuntimeSubsystem</code> implementations are stateful subsystems that provide some specific Beamable functionality. They are built on top of our Auto Generated <code>UBeam____Api</code> classses to make it simpler to leverage our APIs; that way:</p> <ol> <li>You don't have to set up the common case.</li> <li>You can use them and their extension points for variations of the common case.</li> <li>You can use them as reference implementations to implement your own custom use cases outside of the common case.</li> </ol> <p>These are hand-written and, currently, are comprised of:</p> <ul> <li><code>UBeamContentSubsystem</code>: This leverages the Beamable Content system to receive dynamic updates to read-only game data definition; also supports baked in-build content through the same API.</li> <li><code>UBeamInventorySubsystem</code>: This provides builder functions around our Inventory APIs that allows you to combine what would be multiple API requests into a single batched inventory update. It also receives inventory notifications coming from the server and keeps those in sync.</li> <li><code>UBeamMatchmakingSubsystem</code>: This provides you a stateful way of joining/canceling a matchmaking queue and receiving updates when a match is found.</li> </ul> <p>These systems make use of the various <code>UBeamRuntime::____</code> callbacks to keep their state correct and expose callbacks and configuration options for Game-Maker Code to run with semantically relevant guarantees.</p> <p>If the exposed hooks on these are not enough for your use case and constraints, as a user you can create your own <code>UBeamRuntimeSubsystem</code>. The SDK tries not to hide things from you so you can use the provided <code>UBeamRuntimeSubsystems</code> to understand how they are set up when creating your own. The documentation in Lower-Level SDK Subsystems can also be useful when implementing your own <code>UBeamRuntimeSubsystems</code>. </p>"},{"location":"Use%20Guide/Unreal%20SDK%20-%20Runtime%20Concepts/#lower-level-sdk-subsystems","title":"Lower-Level SDK Subsystems","text":"<p>This section talks about lower-level details of how requests to Beamable get made. You don't need to read this, but... you might want to anyway.</p> <p>The lowest layer of systems are shared between the SDK's UE Editor integration and the SDK's Runtime integration:</p> <ul> <li> <p><code>UBeamUserSlots</code>: As explained at the start of this document, tracks multiple local signed-in users (for local co-op cases).</p> </li> <li> <p><code>UBeam_____Api</code>:  Code-Generated Subsystems from our Backend OpenAPI spec.</p> <ul> <li>These are stateless subsystems.</li> <li>These provides you low-level access to every end-point of our backend even if we don't have utilities in the SDK that do exactly what you want.</li> <li>As UE doesn't allow for namespaces AND BP-compatibility, this is verbose. We recommend more liberal use of <code>auto</code> when dealing with Code-Gen API Types.</li> </ul> </li> <li> <p><code>UBeamBackend</code>: Contains BP-Compatible and Lambda compatible implementations of Request/Response handling functions. It handles:</p> <ul> <li>Request/Response serialization and deserialization.</li> <li>Configurable Retry Logic. Request, User and call-site granularity.</li> <li>Transparent and Automatic Re-Auth in case of expired <code>AccessToken</code> through a user's <code>RefreshToken</code>.</li> <li><code>LogBeamBackend Verbose</code> also is a useful diagnostic tool as it will print out the entire process of building the request, sending it out and receiving its response.</li> </ul> </li> <li> <p><code>UBeamNotifications</code> and <code>UBeam_____Notifications</code>: Leverages UE's WebSocket implementation and associates different web-socket connections with different user slots. </p> <ul> <li><code>UBeam_____Notifications</code> are implemented per Beamable backend system (inventory, stats, etc...) to expose two UE function versions, one BP-Compatible and the other Lambda-Compatible, that register a handler to process a specific type of notification.</li> <li>These are used by <code>UBeamRuntimeSubsystem</code> based on their semantic needs. For example, <code>UBeamMatchmakingNotifications</code> subscribes to notifications for the matchmaking ticket while a UserSlot is on a given queue. You can use Microservices to send out custom nofitications --- those can be received in clients by creating your own subsystem modeled after these.</li> </ul> </li> <li> <p><code>UBeamRequestTracker</code>: A BP-compatible implementation of Async Operations that can emit various Events as it goes along --- you can think of these as \"BP-Compatible Promises\".</p> <ul> <li>These are integrated with our <code>UBeam____Api</code> subsystems. </li> <li><code>BeginOperation</code> is effectively the same a creating a new promise. </li> <li><code>TriggerOperationSuccess</code>, <code>TriggerOperationError</code> and <code>TriggerOperationCancelled</code> should be called when you want to complete the Operation.</li> <li>This is a somewhat complex subsystem so we recommend you read Operations &amp; Waits.</li> </ul> </li> </ul> <p>The systems above are used by various environments the Beamable SDK runs in: PIE, Editor, Dedicated Server Builds and regular game builds. Their code is pretty heavily commented and complex; still, feel free to read it and figure things out that way.</p>"}]}